import glob
import numpy as np
import pandas as pd
import networkx as nx
import os
import re
from itertools import combinations_with_replacement
from itertools import combinations
from datetime import datetime
from etl import get_data
import json
import sys

"""
Append a key value pair to a dictionary of list. First need to check if the key is already in the dict_
"""
def dict_append(dict_, key, value):
    if key in dict_.keys():
        dict_[key].add(value)
    else:
        dict_[key] = set([value])
        
"""
Add api edges to the graph by their relation through a dictionary
"""
def add_to_graph(graph, api, key, dict_):
    all_pairs = [(api, other_api) for other_api in dict_[key]]
    graph.add_edges_from(all_pairs)

"""
This is a helper method in printing current time to track the process of this code
"""
def get_time():
    now = datetime.now()
    current_time = now.strftime("%H:%M:%S")
    return "Time: " + current_time

"""
This method is used to extract graph representation of each app.
"""
def get_graphs(all_categories, category_apps_dict):
    app_api_dict = {}
    feature_dict = {}
    for category in all_categories:
        for app in category_apps_dict[category]:
            print("APP: ",app)
            print(get_time())
            B = nx.Graph()
            P = nx.Graph()
            I = nx.Graph()

            ## this line get all smali files that is within this app directory
            all_smali = glob.glob("./smali_files/" + category + '/' + app + "/**/*.smali", recursive = True)

            ## skip those that are too large in terms of smali files
            if len(all_smali) > 5000:
                #all_apps.remove(app)
                continue
            print('num of smalis: ', len(all_smali))


            all_smali_in_one = ''
            for file in all_smali:
                with open(file) as f:
                    content = f.read().strip('\n')
                all_smali_in_one += content + '\t0\n'

            all_smali_in_one = all_smali_in_one.replace('\n', '')
            codeblock_list = re.findall(r'\.method.*?\.end method', all_smali_in_one)

            ## loop through each code block, find all invoke lines and then the api in the invoke line.
            print("working on B")
            for codeblock in codeblock_list:
                invoke_list = set(re.findall(r"(invoke-.*?->.*?)\s",codeblock))
                api_in_block = [invoke.split()[-1] for invoke in invoke_list]
                ## create all possible pairs from api lists and then append to the graph B.
                all_pairs = list(combinations_with_replacement(api_in_block, 2))
                B.add_edges_from(all_pairs)

            ## get all invoke calls from the file
            all_invoke_list = re.findall(r"(invoke-.*?->.*?)\s",all_smali_in_one)
            ## split the all_invoke_list into a list of tuples. Tuple format: (invoke method, api, package)
            all_invoke_tuples = [(invoke.split()[0], invoke.split()[-1], invoke.split()[-1].split('->')[0])
                                for invoke in all_invoke_list]

            ## convert the tuple list to two dictionaries and catch all api
            invoke_api_dict = {}
            package_api_dict = {}
            all_apis = set()
            for invoke_method, api, package in all_invoke_tuples:
                all_apis.add(api)
                invoke_api_dict.setdefault(invoke_method, set()).add(api)
                package_api_dict.setdefault(package, set()).add(api)

            app_api_dict[app] = all_apis

            print("working on I")
            ## in all values of the invoke dictionary, convert it to list and find all possible pairs of the apis for edges.
            for api_list in list(invoke_api_dict.values()):
                all_pairs = list(combinations_with_replacement(api_list, 2))
                I.add_edges_from(all_pairs)
            print("working on P")
            for api_list in list(package_api_dict.values()):
                all_pairs = list(combinations_with_replacement(api_list, 2))
                P.add_edges_from(all_pairs)

            print("Num API: ", len(app_api_dict[app]))
            print(get_time())
            feature_dict[app] = extract_features((B,P,I))
    return feature_dict


def extract_features(BPI_tuple):
    B, P, I = BPI_tuple
    features = []
    features.append(B.number_of_nodes)
    features.append(P.number_of_nodes)
    features.append(I.number_of_nodes)

    features.append(B.number_of_edges)
    features.append(P.number_of_edges)
    features.append(I.number_of_edges)

    B_degrees = [B.degree(node) for node in B.nodes]
    P_degrees = [B.degree(node) for node in B.nodes]
    I_degrees = [B.degree(node) for node in B.nodes]

    features.extend([np.mean(B_degrees), np.mean(B_degrees), np.max(B_degrees)])
    features.extend([np.mean(P_degrees), np.mean(P_degrees), np.max(P_degrees)])
    features.extend([np.mean(I_degrees), np.mean(I_degrees), np.max(I_degrees)])
    return features



def main(targets):
    if 'data' in targets:
        cfg = json.load(open('data-params.json'))
        get_data(**cfg)
    elif 'process' in targets:
        cfg = json.load(open('data-params.json'))
        smali_path =cfg['smali_dir']
        all_categories = next(os.walk('./'+ smali_path +'/', topdown=True))[1]
        category_apps_dict = {}
        for category in all_categories:
            category_apps_dict[category] = next(os.walk("./smali_files/"+category+"/", topdown=True))[1]
        features = get_graphs(all_categories, category_apps_dict)
    elif 'data-test' in targets:
        cfg = json.load(open('test.json'))
        get_data(**cfg)
        cfg = json.load(open('data-params.json'))
        smali_path =cfg['smali_dir']
        all_categories = next(os.walk('./'+ smali_path +'/', topdown=True))[1]
        category_apps_dict = {}
        for category in all_categories:
            category_apps_dict[category] = next(os.walk("./smali_files/"+category+"/", topdown=True))[1]
        features = get_graphs(all_categories, category_apps_dict)
    else:
        print('invalid arguments:', targets)
    return

if __name__ == '__main__':
    targets = sys.argv[1:]
    main(targets)