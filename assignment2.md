In run.py, it takes in smali codes generated by data-injestion.py and works on generating graph representation of each app. And then different features are extracted from theses graph representation as raw data for model training to differentiate between each category of apps.

## Graph Definitions
There are four types of graph generated.
#### A
This is graph in which describes the relationship between Apps and APIs. The node in A can be APIs and APPs. If an API is called within an APP, then, their is an edge between this APP and API. In order to extract all API calls used in the app, we combine all smali files of an app, and uses regex to parse API calls following by "invoke" method.

#### B
This graph is used to indicate whether two APIs is within the same code block, in order to catch unrandom groups of APIs coexist within the same method. A code block is defined as the code between a pair of ".method" and ".end method" in the smali files, which reflects the structural information among the API calls. In graph B, for all APIs within the same code block, there is an edge between all possible pairs. In order to extract all APIs in the same code block, we use regex pattern to find all code blocks in the combined smali file, and extract APIs that are within each code block for edge connections.

#### P
Except for that whether the API calls co-exist in the same code block, API calls which belong to the same package always show similar intent. To represent the relationship of existing in the same package among APIs, we generate the graph P whose nodes are APIs and two APIs are connected by an edge if they are in the same package.

#### I
In smali code, different APIs use different invoke methods, and same invoke method can show the common properties of the API calls. Thus, two API calls using the same invoke method may indicate specifically implicit relations among them. To represent tehis relationship, we uses graph I whose nodes are each APIs and two APIs are connected by an edge if they are in the same package.

## EDA on APPs
In this baseline model, apps are from two different categories. One is "strategy game" while anotther is "board game". I have extracted 25 APPs for strategy game and another 25 for board game. The target here is to extract different features based on graph representation and train a baseline model to predict its category. Here, I extract the number of edges and number of degrees for each graph of the APP as features. The average number of nodes in strategy game is 13702 while that in board game is 8923. This is agreed with common sense as strategy game are way more complicated than a board game, thus should have more nodes. Beyond this, I also calculate the degree of each node in each graph. Then I calcluate the min, max, and mean for all degrees within the same node as features. 

## Baseline Classification Model
With features extracted above, I tried three different classifiers on categorizing the APPs as either "strategy game" or "board game". The three classifiers are logistic regression, random forest and gradient boosted tree. With a train test split of 70:30, the test accuracies are 0.60, 0.80, 0.73 respectively. Since dataset here is small, the result here can only function as a benchmark for the general performance of future algorithms.
